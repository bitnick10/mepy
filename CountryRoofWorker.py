import maya.mel as mel
import maya.cmds as cmds
import random
import math

from Vec3 import Vec3
from Transform import Transform
from Mesh import Mesh
from Tile import Tile

class TileWorker:
    roof = Roof()
    TileXSpace = 0 # percentage of tile width
    NumberOfTileY = 0
    NumberOfTileX = 0
    currentTime = 0
    ExposeDistanceRange = [0,0]
    RotateYRange = [0,0]
    def __init__(self):
        self.SourceUpperTile = Tile()
        if self.UpperTileType == "Normal":
            self.TileXSpace = 0.5

    def DuplicateTile(self):
        for x in range(1,self.NumberOfTileX + 1):
            for y in range(1,self.NumberOfTileY + 1):
                newTile = self.SourceUpperTile.Duplicate()
                pos = Vec3(x * self.SourceUpperTile.GetWidth() * 1.5,0,-y * self.SourceUpperTile.GetLength() * 1.5)
                newTile.Transform.Translate = pos
                newTile.Transform.Rename(self.get_tile_name(x,y))

    def layout_one_column_tiles(self,xn,offsetX):
        positions = []
        for i in range(self.NumberOfTileY):
            #tile = Tile()
            #tile.row = i + 1
            #tile.column = columnNum
            if (i == 0):
                contact = self.roof.Vertexs[0].GetOneCopy()
            else :
                contact = positions[i - 1].GetOneCopy()
                exposeDistance = random.uniform(self.ExposeDistanceRange[0],self.ExposeDistanceRange[1])
                contact.z +=self.SourceUpperTile.GetLength() - exposeDistance
            # print positions[i - 1].ToString()," contact ",contact.ToString()
            pos = self.roof.GetNearestVertex(contact,self.SourceUpperTile.GetLength()).GetOneCopy()
            pos.x += (xn - 1) * offsetX
            positions.append(pos)
        for i,p in enumerate(positions):
            y = i + 1
            tileTransform = Transform()
            tileTransform.Name = self.get_tile_name(xn,y)
            rotateY = random.uniform(self.RotateYRange[0],self.RotateYRange[1])
            tileTransform.Translate = p
            tileTransform.Rotate = Vec3(0,rotateY,0)

    def LayoutTiles(self):
        for i in range(self.NumberOfTileX):
        # for i in range(2):
            self.layout_one_column_tiles(i + 1, self.SourceUpperTile.GetWidth() * (1 + self.TileXSpace))

    def CreatePassiveRigidBody(self, yNum):
        for i in range(self.NumberOfTileX):
            x = i + 1
            name = self.get_tile_name(x,yNum)
            mel.eval("select -r " + name)
            mel.eval("rigidBody -passive -m 1 -dp 0 -sf 1 -df 1 -b 0 -l 0 -tf 200 -iv 0 0 0 -iav 0 0 0 -c 0 -pc 0 -i 0 0 0 -imp 0 0 0 -si 0 0 0 -sio none")
    
    def CreateHingeConstrain(self, yNum):
        for i in range(self.NumberOfTileX):
            x = i + 1
            name = self.get_tile_name(x,yNum)
            mel.eval("connectDynamic - f gravityField1 " + name) 
            mel.eval("select -r " + name)
            mel.eval("constrain - hinge - o 0 90 0")
            move_z = 0.5 * self.SourceUpperTile.GetLength() * -1 
            mel.eval("move - r 0 0 " + str(move_z))

    def RemoveAllByType(self,typeName):
        names = mel.eval("ls -type " + typeName)
        for name in names:
            mel.eval("delete " + name)

    def SimulateTileFall(self):
        self.currentTime += 10
        mel.eval("currentTime " + str(self.currentTime))

    def Simulate(self):
        print "Simulate Begin"
        mel.eval("currentTime 1")
        mel.eval("gravity - pos 0 0 0 - m 9.8 - att 0 - dx 0 - dy - 1 - dz 0  - mxd - 1  - vsh none - vex 0 - vof 0 0 0 - vsw 360 - tsr 0.5")
        mel.eval('setAttr "gravityField1.magnitude" 100')
        for i in range(1,self.NumberOfTileY):
            self.CreatePassiveRigidBody(i)
            self.CreateHingeConstrain(i + 1)
            self.SimulateTileFall()
            self.RemoveAllByType("rigidBody")
            self.RemoveAllByType("rigidConstraint")
        mel.eval("delete gravityField1")
        self.SourceUpperTile.PrintInfo()

    def CreateBelowTile(self):
        for x in range(1,self.NumberOfTileX + 1):
            for y in range(1,self.NumberOfTileY + 1):
                objectName = self.get_tile_name(x,y)
                #print x,y,objectName
                tx = cmds.getAttr(objectName + ".translateX")
                ty = cmds.getAttr(objectName + ".translateY")
                tz = cmds.getAttr(objectName + ".translateZ")
                translate = Vec3(tx,ty,tz)
                rotateX = cmds.getAttr(objectName + ".rotateX")
                rotateY = cmds.getAttr(objectName + ".rotateY")
                rotateZ = cmds.getAttr(objectName + ".rotateZ")
                tile = Tile()
                rotateX *= -1
                # Those data is generated by try
                if(y == 1):
                    translate.y -= self.SourceUpperTile.GetHeight() * 1.6
                    translate.z -= self.SourceUpperTile.GetLength() * 0.2
                elif(y == 2):
                    translate.y -= self.SourceUpperTile.GetHeight() * 2.0
                elif(y == 3):
                    translate.y -= self.SourceUpperTile.GetHeight() * 2.1
                else:
                    translate.y -= self.SourceUpperTile.GetHeight() * 2.2
                translate.x -= self.SourceUpperTile.GetWidth() * (1 - 0.5 * self.TileXSpace)
                mel.eval("rotate -r -os " + str(rotateX) + " 0 180")
                mel.eval("move -r " + translate.ToString())

    def get_tile_name(self, x, y):
        name = "{0}{1}_{2}".format(self.SourceUpperTile.Transform.Name,x,y)
        return name

